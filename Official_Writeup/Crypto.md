# MoeCTF2023 Crypto Writeup
Crypto出题组：koito, shallow

## 前言
MoeCTF2022 Crypto试题 ~~ 落实立德树人根本任务，遵循德智体美劳全面发展要求，贯彻《深化新时代CTF改革总体方案》，体现了MoeCTF改革的方向。试卷突出密码学学科特点，加强基础性与关键能力考查，充分发挥密码学学科的选拔与引导功能。MoeCTF2022 Crypto坚持立德树人，体现CTF文化的育人价值，突出理性思维的价值，注重数学的基础性，引导学生对CTF概念、方法更深刻的认知，在基础性、综合性、应用性、创新性等方面都进行了深入的考查。CTF稳中有变，变中有新，难度设计科学， ~~ 较好的发挥了MoeCTF的选拔功能，对萌新学习密码知识发挥了积极的引导和促进作用。

## crypto指北

直接跑一遍指北最后的脚本即可得到flag

## baby_e

因为e足够小，所以有 `m^e == k * n + c`，直接爆破k即可

可以参考[ctf-wiki](https://ctf-wiki.org/crypto/asymmetric/rsa/rsa_e_attack/#_2)

```python
for k in range(1<<16):
    root, acc = iroot(k*n + c,7)
    if acc:
        print(f"found k={k}")
        print(long_to_bytes(root))
        break
```

## factor_signin

flag分为两部分，前半部分用了两个2048bits的质数，也没有泄漏别的信息，~~所以这是个工具题~~，直接factordb用n1可以查到pq的值；后半部分是20个小质数相乘，可以用yafu快速分解

```python
e = 65537
c1 =  10004937130983861141937782436252502991050957330184611684406783226971057978666503675149401388381995491152372622456604317681236160071166819028679754762162125904637599991943368450200313304999566592294442696755822585022667008378021280392976010576970877334159755332946926433635584313137140987588847077645814987268595739733550220882135750267567373532603503399428451548677091911410732474324157868011686641243202218731844256789044721309478991918322850448456919991540932206923861653518190974620161055008847475600980152660468279765607319838003177639654115075183493029803981527882155542925959658123816315099271123470754815045214896642428657264709805029840253303446203030294879166242867850331945166255924821406218090304893024711068773287842075208409312312188560675094244318565148284432361706108491327014254387317744284876018328591380705408407853404828189643214087638328376675071962141118973835178054884474523241911240926274907256651801384433652425740230755811160476356172444327762497910600719286629420662696949923799255603628210458906831175806791599965316549386396788014703044837917283461862338269599464440202019922379625071512100821922879623930069349084917919100015782270736808388388006084027673781004085620817521378823838335749279055639005125
n1 =  343504538870081878757729748260620800783581983635281373321527119223374418103340873199654926888439040391545101913132680017655039577253974802351999985470115474655124168592386965001556620077117966153475518658881140827499124290142523464795351995478153288872749817655925271395693435582010998996210909883510311066017237567799370371513462802547313382594409676803895262837061350017911885033133654781876923251129406855067993830824618637981136966134029212516871210627954762147349788788999116702635535406398258621926040887099782494271000823401788337120154104692934583729065189687995570122890809807661370008740283447636580308161498808092269041815719148127168137018600113465985504975054319601741498799761500526467431533990903047624407330243357514588557352746347337683868781554819821575385685459666842162355673947984514687068626166144076257334426612302554448774082488600083569900006274897032242821388126274957846236552373226099112200392102883351088570736254707966329366625911183721875374731791052229266503696334310835323523568132399330263642353927504971311717117370721838701629885670598853025212521537158141447625623337563164790788106598854822686494249848796441153496412236527242235888308435573209980270776407776277489669763803746640746378181948641
c2 =  4948422459907576438725352912593232312182623872749480015295307088166392790756090961680588458629287353136729331282506869598853654959933189916541367579979613191505226006688017103736659670745715837820780269669982614187726024837483992949073998289744910800139692315475427811724840888983757813069849711652177078415791290894737059610056340691753379065563574279210755232749774749757141836708161854072798697882671844015773796030086898649043727563289757423417931359190238689436180953442515869613672008678717039516723747808793079592658069533269662834322438864456440701995249381880745586708718334052938634931936240736457181295
n2 =  8582505375542551134698364096640878629785534004976071646505285128223700755811329156276289439920192196962008222418309136528180402357612976316670896973298407081310073283979903409463559102445223030866575563539261326076167685019121804961393115251287057504682389257841337573435085535013992761172452417731887700665115563173984357419855481847035192853387338980937451843809282267888616833734087813693242841580644645315837196205981207827105545437201799441352173638172133698491126291396194764373021523547130703629001683366722885529834956411976212381935354905525700646776572036418453784898084635925476199878640087165680193737
p,q = 19024691283015651666032297670418553586155390575928421823630922553034857624430114628839720683172187406577114034710093054198921843669645736474448836706112221787749688565566635453151716934583685087745112614898780150391513798368931496744574075511968933800467288441832780919514199410584786925010518564670786685241724643282580795568609339268652910564215887176803735675069372979560024792322029911970574914829712553975379661212645059271137916107885326625543090473004683836665262304916304580076748336858662108554591235698235221618061328251985929904075811056422186525179189846420226944944513865790999242309352900287977666792901,18055722101348711626577381571859114850735298658417345663254295930584841136416234624852520581982069555948490061840244710773146585295336094872892685938420880462305333393436098181186277450475949236132458958671804132443554885896037342335902958516394876382378829317303693655605215373555988755516058130500801822723195474873517960624159417903134580987202400855946137101429970119186394052011747475879598126195607938106163892658285305921071673588966184054026228745012993740035399652049777986535759039077634555909031397541116025395236871778797949216479130412500655359057128438928721459688727543057760739527720641179290282309741
primes = [10864078180916418691, 10049235158029375571, 12448177342966243757, 17093292308638969889, 16123604149048919099, 15175734709842430433, 18106525049998616747, 11092420583960163379, 15751974537676958401, 18345408081492711641, 14745811312384518031, 9949603102225364603, 12034779627328165471, 13062839684118954553, 14813953870710226847, 15332916111580607077, 17265001711647542137, 16870346804576162551, 15211380502610462057, 14678737767649343977, 13645878578452317313, 18390046459144888243, 14397830993057803133, 17543713628803023199, 16408421615173973083, 17673334943789572513, 12404642343676224637, 10547615587767500213, 11853704782834170959, 17289161209347211817, 10596280721192026229, 14619040595108594017]
from math import prod
m1 = pow(c1,pow(e,-1,(p-1)*(q-1)),n1)
m2 = pow(c2,pow(e,-1,prod(x-1 for x in primes)),n2)
int.to_bytes(m1,byteorder='big',length=m1.bit_length()//8+1)+int.to_bytes(m2,byteorder='big',length=m2.bit_length()//8+1)
```

## rsa_signin

常见套路题，用不同的n和相同的e加密同一个m。附件给了一堆n和c，按照套路应该是，其中有至少一对n不互质，因此可以用gcd快速分解n。~~然后就有学弟问能不能用CRT来做~~

```python
from math import gcd
c1 = 6269656777204332618433779865483197625538144405832409880710764183039800286008967127279281167109250083159801218370191973055663058165456565194979210256278526713608759141588082614531352489547674696723140599892318118960648862531538435596775798128845789504910467783731144808685373807716609662688064728614003904579841055786083326311313295311152563668422289435606771091246147867715987583149743032723028324394173498623642539175178996531881058274717907066845565199058931743481410454382746158558886667761300257488769795092777021292335562818583719708133179974425584610403335487082478848975656282384575767178925517257692365828720
n1 = 21457499145521259498911107987303777576783467581104197687610588208126845121702391694574491025398113729462454256070437978257494064504146718372095872819969887408622112906108590961892923178192792218161103488204912792358327748493857104191029765218471874759376809136402361582721860433355338373725980783308091544879562698835405262108188595630215081260699112737457564998798692048522706388318528370551365364702529068656665853097899157141017378975007689790000067275142731212069030175682911154288533716549782283859340452266837760560153014200605378914071410125895494331253564598702942990036163269043699029806343766286247742865671
n2 = 14215826065753265334521416948225868542990756976323308408298887797364519400310818641526401662106853573185085731682502059761982246604277475488691297554851873224516934619888327644352138127883043558424300092247604877819821625587944308487310522092440517150600171819145803937177931473336108429889165189521078678397694303305705260759351843006130968234071638035667854938070597400634242396852782331461576526836227336952718230741560369621645218729592233657856104560425642219241082727756696967324334634822771842625681505869025740662258929200756109704988223034840699133778958569054445520305361142302393767439478256174414187983763
p = gcd(n1, n2)
q = n1 // p
e = 65537
phi = (p - 1) * (q - 1)
d = pow(e, -1, phi)
m = pow(c1, d, n1)
print(m.to_bytes((m.bit_length() + 7) // 8, "big"))
```

## |p-q|

p,q 大小相近，那就直接令`p < q`，直接对n开方，去搜索p和q

可以参考[ctf-wiki](https://ctf-wiki.org/crypto/asymmetric/rsa/rsa_module_attack/#p-q_1)

```python
n = 329960318345010350458589325571454799968957932130539403944044204698872359769449414256378111233592533561892402020955736786563103586897940757198920737583107357264433730515123570697570757034221232010688796344257587359198400915567115397034901247038275403825404094129637119512164953012131445747740645183682571690806238508035172474685818036517880994658466362305677430221344381425792427288500814551334928982040579744048907401043058567486871621293983772331951723963911377839286050368715384227640638031857101612517441295926821712605955984000617738833973829140899288164786111118033301974794123637285172303688427806450817155786233788027512244397952849209700013205803489334055814513866650854230478124920442832221946442593769555237909177172933634236392800414176981780444770542047378630756636857018730168151824307814244094763132088236333995807013617801783919113541391133267230410179444855465611792191833319172887852945902960736744468250550722314565805440432977225703650102517531531476188269635151281661081058374242768608270563131619806585194608795817118466680430500830137335634289617464844004904410907221482919453859885955054140320857757297655475489972268282336250384384926216818756762307686391740965586168590784252524275489515352125321398406426217
c = 307746143297103281117512771170735061509547958991947416701685589829711285274762039205145422734327595082350457374530975854337055433998982493020603245187129916580627539476324521854057990929173492940833073106540441902619425074887573232779899379436737429823569006431370954961865581168635086246592539153824456681688944066925973182272443586463636373955966146029489121226571408532284480270826510961605206483011204059402338926815599691009406841471142048842308786000059979977645988396524814553253493672729395573658564825709547262230219183672493306100392069182994445509803952976016630731417479238769736432223194249245020320183199001774879893442186017555682902409661647546547835345461056900610391514595370600575845979413984555709077635397717741521573798309855584473259503981955303774208127361309229536010653615696850725905168242705387575720694946072789441481191449772933265705810128547553027708513478130258801233619669699177901566688737559102165508239876805822898509541232565766265491283807922473440397456701500524925191214292669986798631732639221198138026031561329502985577205314190565609214349344303324429408234237832110076900414483795318189628198913032900272406887003325858236057373096880675754802725017537119549989304878960436575670784578550
from Crypto.Util.number import long_to_bytes
from gmpy2 import iroot
p = iroot(n, 2)[0]
while n % p != 0:
    p -= 1
q = n // p
phi = (p - 1) * (q - 1)
e = 65537
d = pow(e, -1, phi)
m = pow(c, d, n)
print(long_to_bytes(m))
```

## n&n

常见的共摸攻击

可以参考[ctf-wiki](https://ctf-wiki.org/crypto/asymmetric/rsa/rsa_module_attack/#_7)

```python
import gmpy2
from Crypto.Util.number import *
e1 = 0x114514
e2 = 19198101
c1 = 5776799746376051463605370130675046329799612910435315968508603116759552095183027263116443417343895252766060748671845650457077393391989018107887540639775168897954484319381180406512474784571389477212123123540984850033695748142755414954158933345476509573211496722528388574841686164433315356667366007165419697987147258498693175698918104120849579763098045116744389310549687579302444264316133642674648294049526615350011916160649448726069001139749604430982881450187865197137222762758538645387391379108182515717949428258503254717940765994927802512049427407583200118969062778415073135339774546277230281966880715506688898978925
c2 = 4664955020023583143415931782261983177552050757537222070347847639906354901601382630034645762990079537901659753823666851165175187728532569040809797389706253282757017586285211791297567893874606446000074515260509831946210526182765808878824360460569061258723122198792244018463880052389205906620425625708718545628429086424549277715280217165880900037900983008637302744555649467104208348070638137050458275362152816916837534704113775562356277110844168173111385779258263874552283927767924979691542028126412133709129601685315027689094437957165812994784648540588277901241854031439324974562449032290219652206466731675967045633360
n = 13612969130810965900902742090064423006385890357159609755971027204203418808937093492927060428980020085273603754747223030702684866992231913349067578014240319426522039068836171388168087260774376277346092066880984406890296520951318296354893551565670293486797637522297989653182109744864444697818991039473180752980752117041574628063002176339235126861152739066489620021077091941250365101779354009854706729448088217051728432010328667839532327286559570597994183126402340332924370812383312664419874352306052467284992411543921858024469098268800500500651896608097346389396273293747664441553194179933758992070398387066135330851531
g,x,y = gmpy2.gcdext(e1,e2)
print(long_to_bytes((pow(c1,x,n) * pow(c2,y,n))%n))
```

## ez_chain

一个简单的cbc加密，第一个block的明文是已知的，且已知iv，则可以直接求出key，然后解密即可

```python
from Crypto.Util.number import *
base = bytes_to_long(b"koito")

def blockize(long):
    out = []
    while long>0:
        out.append(long % base)
        long //= base
    return list(reversed(out))

def deblockize(blocks):
    out = 0
    for block in blocks:
        out *= base
        out += block
    return out

blocks = [8490961288, 122685644196, 349851982069, 319462619019, 74697733110, 43107579733, 465430019828, 178715374673, 425695308534, 164022852989, 435966065649, 222907886694, 420391941825, 173833246025, 329708930734]

def encrypt_block_cbc(blocks, iv, key):
    encrypted = [iv]
    for i in range(len(blocks)):
        encrypted.append(blocks[i] ^ encrypted[i] ^ key)
    return encrypted[1:]

def decrypt_block_cbc(blocks, iv, key):
    encrypted = [iv,*blocks]
    decrypted = []
    for i in range(len(blocks)):
        decrypted.append(encrypted[i] ^ encrypted[i+1] ^ key)
    return decrypted

iv = 3735927943
key = blockize(bytes_to_long(b"moectf{" + b"A"*64 + b"}"))[0] ^ iv ^ blocks[0]

long_to_bytes(deblockize(decrypt_block_cbc(blocks, iv, key)))
```

## bad_e

经过计算很容易发现 $e$ 与 $\phi(p * q)$ 不互素，更进一步地 $gcd(q-1, e) = 1$ ，我们可以尝试先计算 $m\bmod q$ 的结果，计算 $e * d = 1 (mod \phi(q))$ 。由于此处 $m < q$ ,我们将模换成 $q$ 后解密便得到了明文

```python
from Crypto.Util.number import *
p = 6853495238262155391975011057929314523706159020478084061020122347902601182448091015650787022962180599741651597328364289413042032923330906135304995252477571
q = 11727544912613560398705401423145382428897876620077115390278679983274961030035884083100580422155496261311510530671232666801444557695190734596546855494472819
e = 65537
c = 63388263723813143290256836284084914544524440253054612802424934400854921660916379284754467427040180660945667733359330988361620691457570947823206385692232584893511398038141442606303536260023122774682805630913037113541880875125504376791939861734613177272270414287306054553288162010873808058776206524782351475805
d = pow(e,-1,q-1)
print(long_to_bytes(pow(c%q,d,q)%q))
```

## giant_e

~~这题本来是我随便糊的一个Wiener's Attack，没想到还有基于格密码的做法，看来我的水平还是低了🥺🥺~~

目测e非常大，则d足够小，可以使用[Wiener's Attack](https://ctf-wiki.org/crypto/asymmetric/rsa/d_attacks/rsa_d_attack/#wieners-attack)来获得私钥

```python
from gmpy2 import iroot

def rational_to_contfrac(x,y):
    '''
    Converts a rational x/y fraction into
    a list of partial quotients [a0, ..., an]
    '''
    a = x//y
    pquotients = [a]
    while a * y != x:
        x,y = y,x-a*y
        a = x//y
        pquotients.append(a)
    return pquotients

def convergents_from_contfrac(frac):
    '''
    computes the list of convergents
    using the list of partial quotients
    '''
    convs = []
    for i in range(len(frac)):
        convs.append(contfrac_to_rational(frac[0:i]))
    return convs

def contfrac_to_rational (frac):
    '''Converts a finite continued fraction [a0, ..., an]
     to an x/y rational.
     '''
    if len(frac) == 0:
        return (0,1)
    num = frac[-1]
    denom = 1
    for _ in range(-2,-len(frac)-1,-1):
        num, denom = frac[_]*num+denom, num
    return (num,denom)

def hack_RSA(e,n):
    '''
    Finds d knowing (e,n)
    applying the Wiener continued fraction attack
    '''
    frac = rational_to_contfrac(e, n)
    convergents = convergents_from_contfrac(frac)
    
    for (k,d) in convergents:
        #check if d is actually the key
        if k!=0 and (e*d-1)%k == 0:
            phi = (e*d-1)//k
            s = n - phi + 1
            # check if the equation x^2 - s*x + n = 0
            # has integer roots
            discr = s*s - 4*n
            if(discr>=0):
                r,t = iroot(discr,2)
                if t and (s+r)%2==0:
                    print("Hacked!")
                    return d

n = 0xbaa70ba4c29eb1e6bb3458827540fce84d40e1c966db73c0a39e4f9f40e975c42e02971dab385be27bd2b0687e2476894845cc46e55d9747a5be5ca9d925931ca82b0489e39724ea814800eb3c0ea40d89ebe7fe377f8d3f431a68d209e7a149851c06a4e67db7c99fcfd9ec19496f29d59bb186feb44a36fe344f11d047b9435a1c47fa2f8ed72f59403ebb0e439738fd550a7684247ab7da64311690f461e6dce03bf2fcd55345948a3b537087f07cd680d7461d326690bf21e39dff30268cb33f86eeceff412cd63a38f7110805d337dcad25e6f7e3728b53ca722b695b0d9db37361b5b63213af50dd69ee8b3cf2085f845d7932c08b27bf638e98497239
c = 0x45a9ce4297c8afee693d3cce2525d3399c5251061ddd2462513a57f0fd69bdc74b71b519d3a2c23209d74fcfbcb6b196b5943838c2441cb34496c96e0f9fc9f0f80a2f6d5b49f220cb3e78e36a4a66595aa2dbe3ff6e814d84f07cb5442e2d5d08d08aa9ccde0294b39bfde79a6c6dcd2329e9820744c4deb34a039da7933ddf00b0a0469afb89cba87490a39783a9b2f8f0274f646ca242e78a326dda886c213bc8d03ac1a9150de4ba08c5936c3fe924c8646652ef85aa7ac0103485f472413427a0e9d9a4d416b99e24861ca8499500c693d7a07360158ffffa543480758cafff2a09a9f6628f92767764fa026d48a9dd899838505ae16e38910697f9de14
e = 0x609778981bfbb26bb93398cb6d96984616a6ab08ade090c1c0d4fedb00f44f0552a1555efec5cc66e7960b61e94e80e7483b9f906a6c8155a91cdc3e4917fa5347c58a2bc85bb160fcf7fe98e3645cfea8458ea209e565e4eb72ee7cbb232331a862d8a84d91a0ff6d74aa3c779b2b129c3d8148b090c4193234764f2e5d9b2170a9b4859501d07c0601cdd18616a0ab2cf713a7c785fd06f27d68dff24446d884644e08f31bd37ecf48750e4324f959a8d37c5bef25e1580851646d57b3d4f525bc04c7ddafdf146539a84703df2161a0da7a368675f473065d2cb661907d990ba4a8451b15e054bfc4dd73e134f3bf7d8fa4716125d8e21f946d16b7b0fc43

d = hack_RSA(e,n)
m = pow(c,d,n)
print(int.to_bytes(m, 72, 'big'))
```

## minipack

观察一下可以发现，这个序列是个超递增序列，即序列的每一项都大于先前所有项之和，直接写脚本解密

```python
with open("key.txt") as fs:
    key = eval(fs.read())
with open("ciphertext.txt") as fs:
    c = eval(fs.read())

def bits2long(bits):
    long = 0
    for bit in bits:
        long <<= 1
        long |= bit
    return long

def decrypt(c,keys):
    bits = []
    for k in reversed(keys):
        if c >= k:
            bits.append(1)
            c -= k
        else:
            bits.append(0)
            c-= 1
    assert c == 0,c
    return list(reversed(bits))

print(bits2long(decrypt(c,key)).to_bytes(74))
```

## xorrrrrrrrr

首先得想个办法，加载那一堆数据，所以这里合理运用一下eval（

```python
data = eval("["+",".join(open("result.log").readlines())+"]")
for x in data:
    assert len(x) == 72
```

因为已知部分明文（开头的moectf），所以先对前面的部分xor

```python
strxor = lambda s1,s2: bytes([x^y for x,y in zip(s1,s2)])
partials = []
for x in data:
    print((partial := strxor(b"moectf{",x)))
    partials.append(partial)
```

可以得到很多文章的片段，进行比较

```python
for x in range(100):
    central = partials[x][1:6]
    for y in range(x+1,100):
        if central in partials[y]:
            print(x,y,partials[x],partials[y])
            break
```

可以发现有部分片段的内容是相近的，合理猜测，这些片段可能在文章中是相互重叠的，此处选取28和33进行尝试解密

```python
c1 = data[33]
c2 = data[28]
flag = [ord("m")] + [0]*71
for x in range(1,72):
    flag[x] = flag[x-1] ^ c1[x] ^ c2[x-1]
print(bytes(flag))
```

## flag_exchange

一个简单的Diffie-Hellman Key Exchange，计算出superkey即可得到flag，因此本题可以归结为求离散对数问题，可以用一个光滑数作为p，然后使用sagemath进行计算离散对数

```python
p = 13235062921662694429211184891220141973285969028958016790661658609292023032453887458389574420664371217218833375173082540739555090686687826551693380798574629365254210787419070348340076227508521415632755789594367616391764583712987637766374230688082101873347891400341145784790200266806419168972691757367828474132879
g = 7
alice_c = 1221640590766898549362642749956190247046901295126823096389539054496577676904148725306871415304625357679274758123967130575806395283705650387211451955491880564048849695390063646473446448370517037665298208206300160345895158808656308613957029787101620962105888547352504224570244674070079145383955711162728478536046
bob_c = 10914058150041579228335044825069147660151048009833232499423274241091205307378822591756611171003771345094040632765282436546079380374006417156952521571712847727147667197633718630381965034157472542711445980389164469962687527461825566020040260085757602044987125601005370199841480567305046882686309909194474406616077
c = 4347075310808811365764149394116801872058145217058026761208397630328499276273760675800722813675312623993292132495593299151727221662550697088904575544150269857708718246311308661191716111648871307338719826798387293086431800182087626952538664402203626468441387174230294906432594571442142256792989022176545512970776

F = IntegerModRing(p)
alice = discrete_log(F(alice_c), F(g))
print(alice)

from Crypto.Util.number import long_to_bytes
alice = 37993409039175784589457143359239267408494079933728174984655637174962014403696993530490680524035509941567185477731183292567076906604149806752690437997335275029395313176701922026827247662737470462544532276746044792875332400764315172024417758485968248093577080036097463298532034571247538297840514743856478951558

superkey = pow(bob_c, alice, p)
m = c * pow(superkey, -1, p) % p
print(long_to_bytes(m))
```

## broken_hash

```python
def F(x: int, y: int, z: int) -> int:
    return ((x & ~y) ^ (y & ~z) ^ (z & ~x)) ^ (
        ((x + y) * (y + z) + (x + z)) & 0xFFFF_FFFF_FFFF_FFFF_FFFF_FFFF_FFFF_FFFF
    )


def _block_hash(a: int, b: int, c: int, d: int) -> int:
    x, y, z, w = F(a, b, c), F(b, c, d), F(c, d, a), F(d, a, b)
    return (a ^ b ^ c ^ d ^ x ^ y ^ z ^ w) ^ 0xFFFF_FFFF_FFFF_FFFF_FFFF_FFFF_FFFF_FFFF


def _hash(blocks: list[int]) -> int:
    length = len(blocks)
    if length % 4 != 0:
        padding = 4 - length % 4
        blocks += [0] * padding
        length += padding
    if length == 4:
        return _block_hash(*blocks)
    else:
        block_size = length // 4
        h1 = _hash(blocks[:block_size])
        h2 = _hash(blocks[block_size : block_size * 2])
        h3 = _hash(blocks[block_size * 2 : block_size * 3])
        h4 = _hash(blocks[block_size * 3 :])
        return _block_hash(h1, h2, h3, h4)


def bytes2blocks(data: bytes, block_size=16) -> list[int]:
    if len(data) % block_size != 0:
        data += b"\x00" * (block_size - len(data) % block_size)
    return [
        int.from_bytes(data[i : i + block_size], "little")
        for i in range(0, len(data), block_size)
    ]


def hash(*data: list[bytes]) -> int:
    return _hash(bytes2blocks(b"".join(data)))
```

`_block_hash`接受四个block作为参数，且看起来有轮换对称性，写脚本验证

```python
from itertools import permutations
for i in permutations([b"1",b"2",b"3",b"4"]):
    print(b"".join(i),hash(*(x*16 for x in i)))
```

脚本输出可以验证猜想，存在部分交换使hash不变

```python
from base64 import b64decode,b64encode
data = b64decode("RoZqav2gsy4OrPb9w0dd80XAsmQrbq0UGSvg2H9TYeG9PoepDdhJSCDCXdCc5wotHi6Ua3dN/4rQQ6L6RZpVBDKimKEMnccmz2R6h/6YYjGb7yURhO2bvGr9+JeUjZ/x/9o3IC+gvlJ4TnOGXPi6MKdhr4yZ7OC8UT6Ht9IKZhEzOmw6u9FXr95pnINhdVaqYspJzI21NM7JctkOWrdflIqJG1HC3qxpQ9Xnqn3nfiQmKx4AKrF10F5VhMDPy/ClubMSZVO2ylQ8w+pX2KN0ze2rOrlo3Ogt9+DgAxJokLaSSkwfjylRzVvjSN/4Tvj2GFCkPpFb33QJhF42OrnUpw==")
payload = b""
for x in range(4):
    a = data[64*x:64*x+64]
    for y in range(3,-1,-1):
        b = a[16*y:16*y+16]
        payload += b
b64encode(payload)
```

## factorize_me

~~偷一部分校内选手Orac1e的分析（这水平直接薄纱我了qwq）~~

考察 $RSA$ 中的解密指数 $d$ 泄露问题。

这种问题非常严重，因为我们不仅可以直接解密密文，甚至可以根据 $d,e,N$ 的值来做到有效分解$N$。

在本题中我们知道 $\phi(N)$ 的值，与之等效。

当 $N = pq$ 时，已知 $d * e = 1 + k * \phi(N)$ ，而由欧拉定理知
$$a^{d * e - 1} = 1 \bmod N \quad gcd(a, p * q) = 1$$
注意到 $d * e-1$ 为偶数，则我们可以将其表示为 $2^{t} * g$ 的形式，其中 $g$ 为奇数。
我们计算一下 $a^{d * e-1}-1$ ,得到如下分解：
$$a^{d * e-1} - 1 = a^{2^{t} * g} - 1 = (a^{g} - 1)(a^{g} + 1)(a^{2 * g}+1)\cdots (a^{2^{t-1} * g}+1)=0 \bmod N$$
因为 $N=P * Q$ , $P,Q$ 均为素数。故我们可以计算上述分解式中各项与 $N$ 的最大公约数,如果发现 $GCD(a^{2^{i} * g} - 1, N) \neq 1,N$ ,我们便有效分解掉了 $N$ 。

但是需要注意的是这是一个概率算法，分解的成功与否取决于 $a$ 的选取，根据实际求解的经验，笔者一般是选择用分解出来的因子逐个作为 $a$ ,依次分解，这样的成功率比较高。

```python
n_ = 363364907814244019888662301376841344262476227242899756862391470731421569394957444030214887114615748277199649349781524749919652160244484352285668794188836866602305788131186220057989320357344904731322223310531945208433910803617954798258382169132907508787682006064930747033681966462568715421005454243255297306718356766130469885581576362173340673516476386201173298433892314145854649884922769732583885904512624543994675379894718657682146178638074984373206937523380103438050549181568015985546172618830480078894445808092527561363650503540062128543705172678754195578429520889784813733491180748361345720247750720179608752244490362713103319685024237941527268458213442611663415417005556439749055222361212059968254748751273361732365487788593341859760309778894350385339764442343374673786357175846291309425081492959910254127778240522152676060766139057453197528944251599979227271074508795482632471242983094008619339488744362509349734218480932255216087706001484182136783834973304870508270118505737767002256270427907341952256516206663258530300791364944105025764611810001781971638030661367630116818647252727909489405550104641122269772492252464714694507693447974171377200402508765841829763548525530878309985480248379655169722567051495205792089930014228403456098065971372039443284193603395249634283366194562380309469628114581468645669390610963076340643757972439104287127375438663839421605531570285615180251
phi_ = 363364907814244019888662301376841344262476227242899756862391470731421569394957444030214887114615748277199649349781524749919652160244484352285668794188836492373364350673588273863828369502073826782362255108313852264064760467561392054178047091483873483255491431451728274259516789065331176728192953741805933100379191778599394515981288225535175013258094287912195847642598436035132783919453991516358280321085873745330313812205910011387125778714795906023110368957596998222544234082487264006696812862179916726781327290284827659294751262185328816323311831349296593013038823107653943652771448719760448938995150646738377177532550757319539185878535087009904848382493668686831331474113789651777885239747000076063679062106375348803749466079052774597412239427050432901553466002731972993029311850718200685157193170716432600165476733200831046297530470544781309612128231925681374239849452623513538498417735984094919756374577623486416462101457492789215144166273775249387638107644634704270216130852885082174564648445147377239033930079759024399532146184753110240154062693457622208373371290126810856885343328090305620627668495081760346853701632815149478447405718664667978825807101325764916405446176183238866136433205933785973568759281210319422288153910340542098573782006262190181726245838857185687242960093445000287347616796984610291664809895901301187179157382169999966124177588884152267266994164841066291200
n = 899081756851564072995842371038848265712822308942406479625157544735473115850983700580364485532298999127834142923262920189902691972009898741820291331257478170998867183390650298055916005944577877856728843264502218692432679062445730259562784479410120575777748292393321588239071577384218317338474855507210816917917699500763270490789679076190405915250953860114858086078092945282693720016414837231157788381144668395364877545151382171251673050910143023561541226464220441
e = 65537
c = 841335863342518623856757469220437045493934999201203757845757404101093751603513457430254875658199946020695655428637035628085973393246970440054477600379027466651143466332405520374224855994531411584946074861018245519106776529260649700756908093025092104292223745612991818151040610497258923925952531383407297026038305824754456660932812929344928080812670596607694776017112795053283695891798940700646874515366341575417161087304105309794441077774052357656529143940010140

from Crypto.Util.number import isPrime
from math import gcd
from random import randrange

def factorize_multi_prime(N, phi):
    """
    Recovers the prime factors from a modulus if Euler's totient is known.
    This method works for a modulus consisting of any number of primes, but is considerably be slower than factorize.
    More information: Hinek M. J., Low M. K., Teske E., "On Some Attacks on Multi-prime RSA" (Section 3)
    :param N: the modulus
    :param phi: Euler's totient, the order of the multiplicative group modulo N
    :return: a tuple containing the prime factors
    """
    prime_factors = set()
    factors = [N]
    while len(factors) > 0:
        # Element to factorize.
        N = factors[0]
        w = randrange(2, N - 1)
        i = 1
        while phi % (2**i) == 0:
            sqrt_1 = pow(w, phi // (2**i), N)
            if sqrt_1 > 1 and sqrt_1 != N - 1:
                # We can remove the element to factorize now, because we have a factorization.
                factors = factors[1:]
                p = gcd(N, sqrt_1 + 1)
                q = N // p
                if isPrime(p):
                    prime_factors.add(p)
                elif p > 1:
                    factors.append(p)
                if isPrime(q):
                    prime_factors.add(q)
                elif q > 1:
                    factors.append(q)
                # Continue in the outer loop
                break
            i += 1
    return tuple(prime_factors)

primes = factorize_multi_prime(n_, phi_)
from sympy import nextprime
primes2 = [nextprime(p) for p in primes]
primes3 = [p for p in primes2 if n % p == 0]

from math import prod
from Crypto.Util.number import long_to_bytes
phi = prod(p - 1 for p in primes3)
d = pow(e,-1, phi)
m = pow(c, d, n)
print(long_to_bytes(m))
```

## bad_random

LCG表达式为
$$x_{i+1} = a * x_{i} + c\bmod m$$

相邻项做差得到 $t_{i}$ 序列
$$t_{i+1} = x_{i+2} - x_{i+1} = a * (x_{i+1} - x_{i}) \bmod m$$

易得
$$t_{i+2} * t_{i} - t_{i+1} ^ 2 = (a^2 * t_{i}) * t_{i} - (a * t_{i}) ^ 2 = 0 \bmod m$$

即
$$t_{i+2} * t_{i} - t_{i+1} ^ 2 = k * m ,\quad k \in \mathbb{Z}$$

令
$$m_{i} = t_{i+2} * t_{i} - t_{i+1} ^ 2$$

则对 $m_{i}$ 序列求gcd，大概率为m

```python
from math import gcd
def gcd_all(*args):
    d = args[0]
    for i in args[1:]:
        d = gcd(d,i)
    return d
def solve_m(x_):
    t_ = [x_[i+1] - x_[i] for i in range(len(x_)-1)] 
    m_ = [t_[i+1] * t_[i-1] - t_[i] ** 2 for i in range(1,len(t_)-1)]
    return gcd_all(*m_)
def solve_a(x1,x2,x3,m):
    return ((x3-x2) * pow(x2-x1,-1,m))%m
def solve_c(x1,x2,a,m):
    return (x2-a*x1)%m
```

（交互部分没写，可以手动交互几次求m a c三个参数，然后回代求下个输出，多跑几次一般即可出结果）

## feistel 1/2

*WriteUp by shallow*

两题是一模一样的题面，区别仅在于feistel1给了密钥，仅需要根据加密算法逆向得到解密算法，而feistel2没有给密钥，需要对算法进行分析，从而获取密钥，解密flag。

题目名叫feistel，这是一种重要的对称加密结构，许多常见加密算法都是用了feistel结构，包括DES（现在已经不安全），我国国密算法SM4（使用了非对称feistel结构）等。它的结构如图所示![](./res/1.jpg)可以看到它的最大的特点是加密与解密的结构完全一样，因此在电路实现时不需要额外实现解密电路。同时它不需要f可逆，即使f不可逆，feistel结构仍然还是能够实现加解密。因此相当一部分的对称密码都会采用feistel结构（也有不用的，比如现在更常用的AES使用的是SPN结构）

因此feistel1的解密几乎不需要额外写代码，把题目中的`ebc_enc`函数的第一行删了，直接把密文再丢回去，就能解密成功了。
```python
'''
题目中的enc代码
def ecb_enc(m , key):
    m = padding(m)
    mlen = len(m)
    c = b''
    for i in range(mlen // 16):
        c += enc(m[i*16:i*16+16] , key , round)
    return c   
'''
def ecb_enc(m , key):
    mlen = len(m)
    c = b''
    for i in range(mlen // 16):
        c += enc(m[i*16:i*16+16] , key , round)
    return c
c =b'\x0b\xa7\xc6J\xf6\x80T\xc6\xfbq\xaa\xd8\xcc\x95\xad[\x1e\'W5\xce\x92Y\xd3\xa0\x1fL\xe8\xe1"^\xad'
print(ecb_enc(c , b'wulidego'))
#b'moectf{M@g1cA1_Encr1tion!!!}\x04\x04\x04\x04'
```

而feistel2则需要我们分析中间的函数f。在分析f前，这题和feistel1还有个小区别是多加了个padding，也就是这题会给明文加两个padding以后再加密，那么它会被填充到16的倍数后，再填充16个`b'\x10'`，这是一个已知明文块。根据这个明文块，以及feistel结构，我们可以得到最后一轮的f的输入为密文右半边，输出为密文左半边^明文右半边。因此我们能够得到一组f的输入输出，可以对f进行已知明文攻击。

f的结构如下~~这个函数其实是我自己乱敲的，它甚至在key为偶数的时候不可逆，但好在feistel不需要可逆。敲完发现发现好像能打，就扔上来了~~
```python
def f(m , key):
    m = m ^ (m >> 4)
    m = m ^ (m << 5)
    m = m ^ (m >> 8)
    m ^= key
    m = (m * 1145 + 14)  % 2**64
    m = (m * 1919 + 810) % 2**64 
    m = (m * key) % 2**64
    return m
```
它的前三行是一个常用的可逆线性变换，比如python的random库用的梅森旋转算法就会用到这个变换（可以试试如何逆向）。但在本题中没有作用，因为它在密钥异或前，我们可以直接自己对输入做这三步，就能够直接跳过这部分，仅需要考虑后四行。

后四行先进行了线性的异或运算，再进行了乘法与加法，都是相对异或是非线性运算。这里主要的问题在于模数使用了`2^64`这个2的幂次。因为异或运算是位运算，不同位之间不会相互干扰，而`2^64`同样有部分这样的性质。这里需要一点简单的数论知识（**上过小学**），即模`2^64`成立的方程，模`2^k`，只要k<64，都是成立的。也就是说高位的运算其实不会干扰低位，若我们把k设成1，那么可以有以下的一个函数
```python
def f_last(m,key):
    m ^= key
    m = (m * 1145 + 14)  % 2
    m = (m * 1919 + 810) % 2 
    m = (m * key) % 2
    return m
```
可以验证，这个函数的输出，其实跟原先函数的输出的最低位是相同的。那么这个函数已知明密文求key是非常容易的，因为只有一位，key的取值不是1就是0，枚举一下就行。枚举完就能够得到key的最低位的取值，然后可以逐位增大k，k等于2时，就能够得到key的最后2位，以此类推。也正因为如此，如果真把这个函数展开成逻辑函数，变成方程组，低位的方程不涉及高位变量，逐步求解也是容易的，本题就有选手使用了z3求解，也能很快做出结果。

如果不用z3求解，其实也不是一个循环就能解决的，还是需要一点小技巧。在`f_last`这个函数中，可以发现key不一定是唯一的，可以验证，当`m=1`时，不管key的最后一位是多少，`c=0`都成立（不可逆.jpg），所以这里需要**学过python**，尽管有些情况是存在多个key的，但大部分的key其实还是不满足条件的，因此这里需要一点点算法小技巧，使用广度优先搜索（BFS）去搜索key，从而得到所有key的候选值。
```python
from Crypto.Util.number import *
def pre_rm(rm):
    rm = rm ^ (rm >> 4)
    rm = rm ^ (rm << 5)
    rm = rm ^ (rm >> 8)
    return rm
def f1(rm , rc , m , key):
    rm ^= key
    rm = (rm * 1145 + 14)  % m
    rm = (rm * 1919 + 810) % m 
    rm = (rm * key) % m
    if rm == (rc % m):
        return 1
    else:
        return 0
def getkey(m , c):
    rm = pre_rm(bytes_to_long(m[8:]))
    rc = bytes_to_long(c[8:]) ^ bytes_to_long(m[:8])
    guesslist = [0]
    for i in range(64):
        res = []
        m = 2**(i+1)
        for pre_guess in guesslist:
            guess1 = (1 << i) + pre_guess
            guess0 = pre_guess
            if f1(rm , rc , m , guess0):
                res.append(guess0)
            if f1(rm , rc , m , guess1):
                res.append(guess1)
        guesslist = res
    return guesslist

c = b'B\xf5\xd8gy\x0f\xaf\xc7\xdf\xabn9\xbb\xd0\xe3\x1e0\x9eR\xa9\x1c\xb7\xad\xe5H\x8cC\x07\xd5w9Ms\x03\x06\xec\xb4\x8d\x80\xcb}\xa9\x8a\xcc\xd1W\x82[\xd3\xdc\xb4\x83P\xda5\xac\x9e\xb0)\x98R\x1c\xb3h'
tempm = b'\x10'*16
tempc = c[-16:]
possible_key = getkey(tempm , tempc)
```
本题给的数据大概是有四个候选密钥，但由于解密明文是flag，是可见字符串，并且还有`moectf{}`的前后缀，信息熵不大，因此用这几个候选密钥解密后找可见字符串即可获得flag
```
#四个候选密钥的解密结果
b'moectf{F_func_1s_n1t_Ve5y_$EcU%e}\x0f\x0f\x0f\x0f\x0f\x0f\x0f\x0f\x0f\x0f\x0f\x0f\x0f\x0f\x0f\x10\x10\x10\x10\x10\x10\x10\x10\x10\x10\x10\x10\x10\x10\x10\x10'
b'\x16\xcfectf{F\xdffunc_1s_n1t_Ve5y_$EcU%e\x1b\xaf\x0f\x0f\x0f\x0f\x0f\x0f\x8f\x0f\x0f\x0f\x0f\x0f\x0f\x0f\xfe\xb0\x10\x10\x10\x10\x10\x10\x90\x10\x10\x10\x10\x10\x10\x10'
b'\xab\x0c\n<\xc7\xcf\x1f\x06k\x00{\xd7\x89\x15W\xd9\xaao:\xceTD\x14[\n\xe8\x91u)\x1f.a=9\x8e\xd0\x0c_\xeew\xe2\x14\xe5\xba\x02\xb68\x1d\xf5cb2\x93\xbbM~M\xcf\x05\xc2O7\xe6\x86'
b'\xa6\xbc\n<\xc7\xcf\x1f\x06\xeb\x00{\xd7\x89\x15W\xd9*o:\xceTD\x14[\n\xe8\x91u)\x1f.aa\x89\x8e\xd0\x0c_\xeewb\x14\xe5\xba\x02\xb68\x1d\xae\xf3b2\x93\xbbM~\xcd\xcf\x05\xc2O7\xe6\x86'
```

